name: "review-failure-handling"
version: "2.0.0"
description: "Unified review failure coordination with PM prioritization, duplicate detection, and bulk task creation"

# ARCHITECTURE CHANGE (v2.0.0):
# - Now handles ALL review types uniformly (qa, code_review, security_review, devops_review)
# - QA failures use same pattern as code/security (removed iterative retry loop)
# - PM evaluates ALL review failures and decides: retry immediately, create tasks, or defer
# - Duplicate task detection prevents creating tasks that already exist
# - TDD-aware for all review types (not just QA)

# Trigger condition (always run when called as sub-workflow)
trigger:
  condition: "true"

# Context requirements
context:
  repo_required: false
  branch_strategy: "inherit"

# Input schema (documented for reference, validated by SubWorkflowStep)
# inputs:
#   review_type: string (required) - qa | code_review | security_review | devops_review
#   review_result: object (required) - Full review result output
#   review_status: string (required) - pass | fail | unknown
#   milestone_context: object (required) - Current milestone information
#   task: object (required) - Current task being processed
#   parent_task_id: string (optional) - ID of parent task for urgent subtasks
#   priority_scores: object (required) - urgent and deferred priority scores
#   config: object (optional) - Configuration options
#   project_id: string (required)
#   repo: string (required)
#   tdd_aware: boolean (optional) - Whether task is implementing a failing test (TDD workflow)
#   tdd_stage: string (optional) - Current TDD stage (write_failing_test | failing_test | implementation | passing_test)
#   existing_tasks: array (optional) - List of existing tasks on dashboard for duplicate detection
#   diff_changed_files: array (optional) - Files modified in the current review branch
#   diff_summary: string (optional) - Git diff summary between feature branch and base

# Steps
steps:
  # Step 1: Check TDD awareness (skip task creation during failing test stage)
  - name: check_tdd_gate
    type: ConditionalStep
    description: "Skip task creation if in TDD failing test stage"
    config:
      condition: "tdd_aware == true && (tdd_stage == 'write_failing_test' || tdd_stage == 'failing_test')"
      on_true:
        action: "skip_remaining"
        message: "Skipping task creation: TDD failing test stage"
      on_false:
        action: "continue"
    outputs:
      - should_skip

  # Step 2: PM evaluates failures and decides priority
  - name: pm_evaluation
    type: PersonaRequestStep
    description: "PM evaluates review failures and prioritizes follow-up work"
    depends_on: ["check_tdd_gate"]
    config:
      step: "pm-review-prioritization"
      persona: "project-manager"
      intent: "prioritize_review_failures"
      prompt_template: "prompts/pm-review-prioritization.txt"
      payload:
        review_type: "${review_type}"
        review_result: "${review_result}"
        review_status: "${review_status}"
        task: "${task}"
        milestone: "${milestone_context}"
        project_id: "${project_id}"
        repo: "${repo}"
        tdd_aware: "${tdd_aware || false}"
        tdd_stage: "${tdd_stage || 'implementation'}"
        existing_tasks: "${existing_tasks || []}"
        diff_summary: "${diff_summary || ''}"
        diff_changed_files: "${diff_changed_files || []}"
    outputs:
      - pm_decision

  # Step 3: Parse PM decision and normalize format
  - name: parse_pm_decision
    type: PMDecisionParserStep
    description: "Parse and normalize PM decision (handles multiple formats)"
    depends_on: ["pm_evaluation"]
    config:
      input: "${pm_decision}"
      normalize: true
      review_type: "${review_type}"
    outputs:
      - decision
      - reasoning
      - immediate_issues
      - deferred_issues
      - follow_up_tasks

  - name: filter_follow_up_tasks
    type: ReviewFollowUpFilterStep
    description: "Filter PM follow-ups using milestone context, diff data, and existing backlog"
    depends_on: ["parse_pm_decision"]
    condition: "parse_pm_decision.follow_up_tasks.length > 0"
    config:
      tasks: "${parse_pm_decision.follow_up_tasks}"
      existing_tasks: "${existing_tasks || []}"
      milestone_context: "${milestone_context}"
      task: "${task}"
      review_type: "${review_type}"
      diff_changed_files: "${diff_changed_files || []}"
    outputs:
      - filtered_tasks
      - dropped_tasks

  # Step 4: Create tasks in bulk (with duplicate detection)
  - name: create_tasks_bulk
    type: BulkTaskCreationStep
    description: "Create all follow-up tasks in single bulk operation with duplicate detection"
    depends_on: ["filter_follow_up_tasks"]
    condition: "filter_follow_up_tasks.filtered_tasks.length > 0"
    config:
      project_id: "${project_id}"
      tasks: "${filter_follow_up_tasks.filtered_tasks}"
      priority_mapping:
        critical: "${priority_scores.urgent}"
        high: "${priority_scores.urgent}"
        medium: "${priority_scores.deferred}"
        low: "${priority_scores.deferred}"
      milestone_strategy:
        urgent: "${milestone_context.id}"
        deferred: "${config.backlog_milestone_slug || 'future-enhancements'}"
      parent_task_mapping:
        urgent: "${parent_task_id}"
        deferred: null
      options:
        create_milestone_if_missing: true
        upsert_by_external_id: true
        external_id_template: "${review_type}-${task.id}-${task.title_slug}"
        check_duplicates: true
        existing_tasks: "${existing_tasks || []}"
        duplicate_match_strategy: "content_hash"
    outputs:
      - tasks_created
      - urgent_tasks_created
      - deferred_tasks_created
      - task_ids
      - skipped_duplicates
      - duplicate_task_ids

  - name: register_follow_up_dependencies
    type: RegisterBlockedDependenciesStep
    description: "Attach newly created task ids to the blocked parent"
    depends_on: ["create_tasks_bulk"]
    condition: "parent_task_id && create_tasks_bulk.task_ids.length > 0"
    config:
      project_id: "${project_id}"
      parent_task_id: "${parent_task_id}"
      dependency_task_ids: "${create_tasks_bulk.task_ids}"
    outputs:
      - dependencyCount
      - addedDependencies

  # Step 5: Mark original task as blocked (if configured)
  - name: mark_original_blocked
    type: SimpleTaskStatusStep
    description: "Mark original task as blocked to prevent loop"
    depends_on: ["register_follow_up_dependencies"]
    condition: "config.block_original_task == true && urgent_tasks_created > 0"
    config:
      status: "blocked"
      comment: "${review_type} failed - ${urgent_tasks_created} urgent tasks created"
      task_id: "${task.id}"
      project_id: "${project_id}"
    outputs:
      - original_task_blocked

# Output mappings (returned to parent workflow)
# These are accessed via context.getVariable() in parent
outputs:
  tasks_created: "${create_tasks_bulk.tasks_created || 0}"
  urgent_tasks_created: "${create_tasks_bulk.urgent_tasks_created || 0}"
  deferred_tasks_created: "${create_tasks_bulk.deferred_tasks_created || 0}"
  task_ids: "${create_tasks_bulk.task_ids || []}"
  duplicate_task_ids: "${create_tasks_bulk.duplicate_task_ids || []}"
  pm_decision: "${parse_pm_decision.pm_decision}"
  original_task_blocked: "${mark_original_blocked.original_task_blocked || false}"
  skipped_duplicates: "${create_tasks_bulk.skipped_duplicates || 0}"
