name: "legacy-compatible-task-flow"
description: "Task processing workflow that implements the exact business logic patterns expected by legacy tests"
version: "1.0.0"
trigger:
  condition: "task_type == 'task' || task_type == 'feature'"
context:
  repo_required: true
  branch_strategy: "feature-branch"

steps:
  # Git setup - checkout feature branch
  - name: checkout_branch
    type: GitOperationStep
    description: "Checkout feature branch from base branch"
    config:
      operation: "checkoutBranchFromBase"
      baseBranch: "main"
      newBranch: "feat/task"

  # Context gathering
  - name: context_request
    type: PersonaRequestStep
    description: "Request context gathering from contextualizer persona"
    depends_on: ["checkout_branch"]
    config:
      step: "1-context"
      persona: "contextualizer"
      intent: "context_gathering"
      payload:
        task: "${task}"
        repo: "${repoRoot}"
        project_id: "${projectId}"
        milestone: "${milestone}"
        milestone_name: "${milestone_name}"

  # Planning with evaluation loop (encapsulates plan creation and evaluation)
  - name: planning_loop
    type: PlanningLoopStep
    description: "Plan creation and evaluation loop with max 5 iterations"
    depends_on: ["context_request"]
    config:
      maxIterations: 5
      plannerPersona: "implementation-planner"
      evaluatorPersona: "plan-evaluator" 
      planStep: "2-plan"
      evaluateStep: "2.5-evaluate-plan"
      payload:
        task: "${task}"
        context: "${context_request_result}"
        repo: "${repoRoot}"
        project_id: "${projectId}"

  # Implementation
  - name: implementation_request
    type: PersonaRequestStep
    description: "Request implementation from lead engineer persona"
    depends_on: ["planning_loop"]
    config:
      step: "2-implementation"
      persona: "lead-engineer"
      intent: "implementation"
      payload:
        task: "${task}"
        plan: "${planning_loop_plan_result}"
        repo: "${repoRoot}"
        project_id: "${projectId}"

  # Apply implementation edits to repository  
  - name: apply_implementation_edits
    type: DiffApplyStep
    description: "Parse and apply implementation edits from lead engineer"
    depends_on: ["implementation_request"]
    config:
      source_output: "implementation_request"
      validation: "syntax_check"
      commit_message: "feat: implement ${taskName}"

  # Commit and push changes after implementation
  - name: commit_implementation
    type: GitOperationStep
    description: "Commit and push implementation changes"
    depends_on: ["apply_implementation_edits"]
    config:
      operation: "commitAndPushPaths"
      message: "feat: implement ${taskName}"
      paths: ["*"]

  # Verify changes were pushed
  - name: verify_diff
    type: GitOperationStep
    description: "Verify remote branch has diff from base"
    depends_on: ["commit_implementation"]
    config:
      operation: "verifyRemoteBranchHasDiff"

  # Ensure branch is published before code-related personas begin
  - name: ensure_branch_published
    type: GitOperationStep
    description: "Ensure branch is published to remote before code reviews"
    depends_on: ["verify_diff"]
    config:
      operation: "ensureBranchPublished"

  # QA - depends on git operations being complete
  - name: qa_request
    type: PersonaRequestStep
    description: "Request QA review from QA engineer persona"
    depends_on: ["ensure_branch_published"]
    outputs: ["qa_request_result"]
    config:
      step: "3-qa"
      persona: "qa-engineer"
      intent: "qa"
      payload:
        task: "${task}"
        plan: "${planning_loop_plan_result}"
        implementation: "${implementation_request_result}"
        repo: "${repoRoot}"
        project_id: "${projectId}"

  # QA Failure Coordination - handles all QA failure logic declaratively
  - name: qa_failure_coordination
    type: QAFailureCoordinationStep
    description: "Coordinate QA failures with plan revision and task creation"
    depends_on: ["qa_request"]
    condition: "${qa_request_status} == 'fail'"
    config:
      maxPlanRevisions: 5
      taskCreationStrategy: "auto"
      tddAware: true
      evaluationStep: "evaluate-qa-plan"
      revisionStep: "qa-plan-revision"
      createdTasksStep: "qa-created-tasks"

  # Handle QA created tasks - triggered when QA fails regardless of task source
  - name: qa_created_tasks
    type: PersonaRequestStep
    description: "Handle QA-created tasks via implementation planner"
    depends_on: ["qa_request"]
    condition: "${qa_request_status} == 'fail'"
    config:
      step: "qa-created-tasks"
      persona: "implementation-planner"
      intent: "planning"
      payload:
        task: "${task}"
        qa_result: "${qa_request_result}"
        created_tasks: "${qa_failure_created_tasks}"
        repo: "${repoRoot}"
        project_id: "${projectId}"

  # Execute the QA follow-up plan - implementation step
  - name: qa_followup_implementation
    type: PersonaRequestStep
    description: "Execute the QA follow-up implementation plan"
    depends_on: ["qa_created_tasks"]
    condition: "${qa_request_status} == 'fail'"
    config:
      step: "4-implementation-plan"
      persona: "lead-engineer"
      intent: "implementation"
      payload:
        task: "${task}"
        plan: "${qa_created_tasks_result}"
        context: "${context_request_result}"
        repo: "${repoRoot}"
        project_id: "${projectId}"  # Code Review - depends on git operations being complete
  - name: code_review_request
    type: PersonaRequestStep
    description: "Request code review from code reviewer persona"
    depends_on: ["qa_request"]
    condition: "${qa_request_status} == 'pass'"
    config:
      step: "3-code-review"
      persona: "code-reviewer"
      intent: "code_review"
      payload:
        task: "${task}"
        plan: "${planning_loop_plan_result}"
        implementation: "${implementation_request_result}"
        qa_result: "${qa_request_result}"
        repo: "${repoRoot}"
        project_id: "${projectId}"

  # Security Review - depends on git operations being complete
  - name: security_request
    type: PersonaRequestStep
    description: "Request security review from security reviewer persona"
    depends_on: ["qa_request"]
    condition: "${qa_request_status} == 'pass'"
    config:
      step: "3-security"
      persona: "security-review"
      intent: "security_review"
      payload:
        task: "${task}"
        plan: "${planning_loop_plan_result}"
        implementation: "${implementation_request_result}"
        qa_result: "${qa_request_result}"
        code_review_result: "${code_review_request_result}"
        repo: "${repoRoot}"
        project_id: "${projectId}"

  # DevOps Review - depends on git operations being complete
  - name: devops_request
    type: PersonaRequestStep
    description: "Request DevOps review from DevOps persona"
    depends_on: ["code_review_request", "security_request"]
    condition: "${qa_request_status} == 'pass'"
    config:
      step: "3-devops"
      persona: "devops"
      intent: "devops_review"
      payload:
        task: "${task}"
        plan: "${planning_loop_plan_result}"
        implementation: "${implementation_request_result}"
        qa_result: "${qa_request_result}"
        code_review_result: "${code_review_request_result}"
        security_result: "${security_request_result}"
        repo: "${repoRoot}"
        project_id: "${projectId}"

  # Mark task as done
  - name: mark_task_done
    type: SimpleTaskStatusStep
    description: "Mark task as completed on dashboard"
    depends_on: ["security_request", "devops_request", "code_review_request"]
    config:
      task_id: "${taskId}"
      project_id: "${projectId}"
      status: "done"