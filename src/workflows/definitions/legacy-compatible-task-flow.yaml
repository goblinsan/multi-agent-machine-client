name: "legacy-compatible-task-flow"
description: "Task processing workflow that implements the exact business logic patterns expected by legacy tests"
version: "1.0.0"
trigger:
  condition: "task_type == 'task' || task_type == 'feature'"
context:
  repo_required: true
  branch_strategy: "feature-branch"

steps:
  # Git setup - checkout feature branch based on milestone
  - name: checkout_branch
    type: GitOperationStep
    description: "Checkout feature branch from base branch using milestone slug from dashboard"
    config:
      operation: "checkoutBranchFromBase"
      baseBranch: "main"
      # Use milestone slug for branch name - will be dynamically resolved
      # Falls back to feat/task if milestone_slug is not available
      newBranch: "${featureBranchName}"

  # Mark task as in progress immediately after starting
  - name: mark_task_in_progress
    type: SimpleTaskStatusStep
    description: "Mark task as in progress on dashboard"
    depends_on: ["checkout_branch"]
    config:
      status: "in_progress"

  # Context gathering
  - name: context_request
    type: PersonaRequestStep
    description: "Request context gathering from context persona"
    depends_on: ["mark_task_in_progress"]
    config:
      step: "1-context"
      persona: "context"
      intent: "context_gathering"
      payload:
        task: "${task}"
        repo: "${repo_remote}"
        project_id: "${projectId}"
        milestone: "${milestone}"
        milestone_name: "${milestone_name}"

  # Planning with evaluation loop (encapsulates plan creation and evaluation)
  - name: planning_loop
    type: PlanningLoopStep
    description: "Plan creation and evaluation loop with max 5 iterations"
    depends_on: ["context_request"]
    config:
      maxIterations: 5
      plannerPersona: "implementation-planner"
      evaluatorPersona: "plan-evaluator" 
      planStep: "2-plan"
      evaluateStep: "2.5-evaluate-plan"
      payload:
        task: "${task}"
        context: "${context_request_result}"
        repo: "${repo_remote}"
        project_id: "${projectId}"

  # Implementation
  - name: implementation_request
    type: PersonaRequestStep
    description: "Request implementation from lead engineer persona"
    depends_on: ["planning_loop"]
    config:
      step: "2-implementation"
      persona: "lead-engineer"
      intent: "implementation"
      # timeout not set - will use persona-specific timeout from PERSONA_TIMEOUTS_JSON env (600s for lead-engineer)
      payload:
        task: "${task}"
        plan: "${planning_loop_plan_result}"
        repo: "${repo_remote}"
        project_id: "${projectId}"

  # Apply implementation edits to repository
  # NOTE: This step now handles commit AND push internally via applyEditOps
  - name: apply_implementation_edits
    type: DiffApplyStep
    description: "Parse, apply, commit, and push implementation edits from lead engineer"
    depends_on: ["implementation_request"]
    config:
      source_output: "implementation_request"
      validation: "syntax_check"
      commit_message: "feat: implement ${taskName}"

  # Verify changes were pushed
  - name: verify_diff
    type: GitOperationStep
    description: "Verify remote branch has diff from base"
    depends_on: ["apply_implementation_edits"]
    config:
      operation: "verifyRemoteBranchHasDiff"

  # Ensure branch is published before code-related personas begin
  - name: ensure_branch_published
    type: GitOperationStep
    description: "Ensure branch is published to remote before code reviews"
    depends_on: ["verify_diff"]
    config:
      operation: "ensureBranchPublished"

  # QA - depends on git operations being complete
  - name: qa_request
    type: PersonaRequestStep
    description: "Request QA review from tester-qa persona"
    depends_on: ["ensure_branch_published"]
    outputs: ["qa_request_result"]
    config:
      step: "3-qa"
      persona: "tester-qa"
      intent: "qa"
      payload:
        task: "${task}"
        plan: "${planning_loop_plan_result}"
        implementation: "${implementation_request_result}"
        repo: "${repo_remote}"
        project_id: "${projectId}"

  # QA Failure Coordination - handles all QA failure logic declaratively
  - name: qa_failure_coordination
    type: QAFailureCoordinationStep
    description: "Coordinate QA failures with plan revision and task creation"
    depends_on: ["qa_request"]
    condition: "${qa_request_status} == 'fail'"
    config:
      maxPlanRevisions: 5
      taskCreationStrategy: "auto"
      tddAware: true
      evaluationStep: "evaluate-qa-plan"
      revisionStep: "qa-plan-revision"
      createdTasksStep: "qa-created-tasks"

  # Iterative QA fix loop - keeps trying until QA passes or max iterations reached
  # Uses COORDINATOR_MAX_REVISION_ATTEMPTS from env (supports "unlimited")
  - name: qa_iteration_loop
    type: QAIterationLoopStep
    description: "Iteratively fix QA failures: plan → implement → apply → commit → retest"
    depends_on: ["qa_failure_coordination"]
    condition: "${qa_request_status} == 'fail'"
    config:
      maxIterations: null  # null = unlimited (respects env COORDINATOR_MAX_REVISION_ATTEMPTS)
      planningStep: "qa-fix-planning"
      implementationStep: "qa-fix-implementation"
      qaRetestStep: "qa-retest"

  # Mark task as in review when QA passes and entering review stages
  - name: mark_task_in_review
    type: SimpleTaskStatusStep
    description: "Mark task as in review on dashboard"
    depends_on: ["qa_request", "qa_iteration_loop"]
    condition: "${qa_request_status} == 'pass'"
    config:
      status: "in_review"

  # Code Review - depends on QA passing (either first time or after iteration loop)
  - name: code_review_request
    type: PersonaRequestStep
    description: "Request code review from code reviewer persona"
    depends_on: ["mark_task_in_review"]
    condition: "${qa_request_status} == 'pass'"
    config:
      step: "3-code-review"
      persona: "code-reviewer"
      intent: "code_review"
      payload:
        task: "${task}"
        plan: "${planning_loop_plan_result}"
        implementation: "${implementation_request_result}"
        qa_result: "${qa_request_result}"
        repo: "${repo_remote}"
        project_id: "${projectId}"

  # Security Review - depends on QA passing (either first time or after iteration loop)
  - name: security_request
    type: PersonaRequestStep
    description: "Request security review from security reviewer persona"
    depends_on: ["mark_task_in_review"]
    condition: "${qa_request_status} == 'pass'"
    config:
      step: "3-security"
      persona: "security-review"
      intent: "security_review"
      payload:
        task: "${task}"
        plan: "${planning_loop_plan_result}"
        implementation: "${implementation_request_result}"
        qa_result: "${qa_request_result}"
        code_review_result: "${code_review_request_result}"
        repo: "${repo_remote}"
        project_id: "${projectId}"

  # DevOps Review - depends on git operations being complete
  - name: devops_request
    type: PersonaRequestStep
    description: "Request DevOps review from DevOps persona"
    depends_on: ["code_review_request", "security_request"]
    condition: "${qa_request_status} == 'pass'"
    config:
      step: "3-devops"
      persona: "devops"
      intent: "devops_review"
      payload:
        task: "${task}"
        plan: "${planning_loop_plan_result}"
        implementation: "${implementation_request_result}"
        qa_result: "${qa_request_result}"
        code_review_result: "${code_review_request_result}"
        security_result: "${security_request_result}"
        repo: "${repo_remote}"
        project_id: "${projectId}"

  # Mark task as done
  - name: mark_task_done
    type: SimpleTaskStatusStep
    description: "Mark task as completed on dashboard"
    depends_on: ["security_request", "devops_request", "code_review_request"]
    config:
      task_id: "${taskId}"
      project_id: "${projectId}"
      status: "done"

  # Check milestone completion status
  - name: check_milestone_completion
    type: MilestoneStatusCheckStep
    description: "Check if milestone has remaining incomplete tasks"
    depends_on: ["mark_task_done"]
    config:
      check_type: "incomplete_tasks"
      include_cancelled: false

  # Send suggested tasks to PM for urgency evaluation if milestone incomplete
  - name: pm_evaluate_suggestions
    type: PersonaRequestStep
    description: "Send suggested tasks to PM for urgency evaluation"
    depends_on: ["check_milestone_completion"]
    condition: "${milestone_has_remaining_tasks} == true"
    config:
      step: "6-pm-evaluate-suggestions"
      persona: "project-manager"
      intent: "evaluate_task_urgency"
      payload:
        milestone: "${milestone}"
        completed_task: "${task}"
        remaining_tasks: "${check_milestone_completion_remaining_tasks}"
        suggested_tasks: "${qa_iteration_loop_suggested_tasks}"
        milestone_completion_percentage: "${milestone_completion_percentage}"
        repo: "${repo_remote}"
        project_id: "${projectId}"

# Failure handling - mark task as blocked when workflow fails
failure_handling:
  on_workflow_failure:
    - name: mark_task_blocked
      type: SimpleTaskStatusStep
      description: "Mark task as blocked when workflow fails"
      config:
        status: "blocked"

# Workflow timeouts
timeouts:
  context_request_timeout: 600000  # 10 minutes for context gathering
  default_step: 300000  # 5 minutes default