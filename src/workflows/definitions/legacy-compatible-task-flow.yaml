name: "legacy-compatible-task-flow"
description: "Task processing workflow that implements the exact business logic patterns expected by legacy tests"
version: "1.0.0"
trigger:
  condition: "task_type == 'task' || task_type == 'feature'"
context:
  repo_required: true
  branch_strategy: "feature-branch"

steps:
  # Git setup - checkout feature branch based on milestone
  - name: checkout_branch
    type: GitOperationStep
    description: "Checkout feature branch from base branch using milestone slug from dashboard"
    config:
      operation: "checkoutBranchFromBase"
      baseBranch: "main"
      # Use milestone slug for branch name - will be dynamically resolved
      # Falls back to feat/task if milestone_slug is not available
      newBranch: "${featureBranchName}"

  # Mark task as in progress immediately after starting
  - name: mark_task_in_progress
    type: SimpleTaskStatusStep
    description: "Mark task as in progress on dashboard"
    depends_on: ["checkout_branch"]
    config:
      status: "in_progress"

  # Context gathering
  - name: context_request
    type: PersonaRequestStep
    description: "Request context gathering from context persona"
    depends_on: ["mark_task_in_progress"]
    config:
      step: "1-context"
      persona: "context"
      intent: "context_gathering"
      payload:
        task: "${task}"
        repo: "${repo_remote}"
        project_id: "${projectId}"
        milestone: "${milestone}"
        milestone_name: "${milestone_name}"

  # Planning with evaluation loop (encapsulates plan creation and evaluation)
  - name: planning_loop
    type: PlanningLoopStep
    description: "Plan creation and evaluation loop with max 5 iterations"
    depends_on: ["context_request"]
    config:
      maxIterations: 5
      plannerPersona: "implementation-planner"
      evaluatorPersona: "plan-evaluator" 
      planStep: "2-plan"
      evaluateStep: "2.5-evaluate-plan"
      payload:
        task: "${task}"
        context: "${context_request_result}"
        repo: "${repo_remote}"
        project_id: "${projectId}"

  # Implementation
  - name: implementation_request
    type: PersonaRequestStep
    description: "Request implementation from lead engineer persona"
    depends_on: ["planning_loop"]
    config:
      step: "2-implementation"
      persona: "lead-engineer"
      intent: "implementation"
      # timeout not set - will use persona-specific timeout from PERSONA_TIMEOUTS_JSON env (600s for lead-engineer)
      payload:
        task: "${task}"
        plan: "${planning_loop_plan_result}"
        repo: "${repo_remote}"
        project_id: "${projectId}"

  # Apply implementation edits to repository
  # NOTE: This step now handles commit AND push internally via applyEditOps
  - name: apply_implementation_edits
    type: DiffApplyStep
    description: "Parse, apply, commit, and push implementation edits from lead engineer"
    depends_on: ["implementation_request"]
    config:
      source_output: "implementation_request"
      validation: "syntax_check"
      commit_message: "feat: implement ${taskName}"

  # Verify changes were pushed
  - name: verify_diff
    type: GitOperationStep
    description: "Verify remote branch has diff from base"
    depends_on: ["apply_implementation_edits"]
    config:
      operation: "verifyRemoteBranchHasDiff"

  # Ensure branch is published before code-related personas begin
  - name: ensure_branch_published
    type: GitOperationStep
    description: "Ensure branch is published to remote before code reviews"
    depends_on: ["verify_diff"]
    config:
      operation: "ensureBranchPublished"

  # QA - depends on git operations being complete
  - name: qa_request
    type: PersonaRequestStep
    description: "Request QA review from tester-qa persona"
    depends_on: ["ensure_branch_published"]
    outputs: ["qa_request_result"]
    config:
      step: "3-qa"
      persona: "tester-qa"
      intent: "qa"
      payload:
        task: "${task}"
        plan: "${planning_loop_plan_result}"
        implementation: "${implementation_request_result}"
        repo: "${repo_remote}"
        project_id: "${projectId}"

  # QA Failure Coordination - handles all QA failure logic declaratively
  - name: qa_failure_coordination
    type: QAFailureCoordinationStep
    description: "Coordinate QA failures with plan revision and task creation"
    depends_on: ["qa_request"]
    condition: "${qa_request_status} == 'fail'"
    config:
      maxPlanRevisions: 5
      taskCreationStrategy: "auto"
      tddAware: true
      evaluationStep: "evaluate-qa-plan"
      revisionStep: "qa-plan-revision"
      createdTasksStep: "qa-created-tasks"
      urgentPriorityScore: 1200  # QA failures prioritized between code review (1000) and security (1500)
      deferredPriorityScore: 50  # Non-urgent QA improvements go to backlog

  # Iterative QA fix loop - keeps trying until QA passes or max iterations reached
  # Uses COORDINATOR_MAX_REVISION_ATTEMPTS from env (supports "unlimited")
  - name: qa_iteration_loop
    type: QAIterationLoopStep
    description: "Iteratively fix QA failures: plan → implement → apply → commit → retest"
    depends_on: ["qa_failure_coordination"]
    condition: "${qa_request_status} == 'fail'"
    config:
      maxIterations: null  # null = unlimited (respects env COORDINATOR_MAX_REVISION_ATTEMPTS)
      planningStep: "qa-fix-planning"
      implementationStep: "qa-fix-implementation"
      qaRetestStep: "qa-retest"

  # Mark task as in review when QA passes (either first time or after iteration loop)
  - name: mark_task_in_review
    type: SimpleTaskStatusStep
    description: "Mark task as in review on dashboard when QA passes"
    depends_on: ["qa_request"]
    condition: "${qa_request_status} == 'pass'"
    config:
      status: "in_review"

  # Code Review - evaluates code quality, style, and best practices
  - name: code_review_request
    type: PersonaRequestStep
    description: "Request code review from code reviewer persona"
    depends_on: ["mark_task_in_review"]
    outputs: ["code_review_request_result", "code_review_request_status"]
    config:
      step: "4-code-review"
      persona: "code-reviewer"
      intent: "code_review"
      payload:
        task: "${task}"
        plan: "${planning_loop_plan_result}"
        implementation: "${implementation_request_result}"
        qa_result: "${qa_request_result}"
        repo: "${repo_remote}"
        project_id: "${projectId}"

  # PM prioritizes code review failures - decides if issues need immediate fix or can be deferred
  - name: pm_prioritize_code_review_failures
    type: PersonaRequestStep
    description: "PM evaluates code review failures and prioritizes follow-up work"
    depends_on: ["code_review_request"]
    condition: "${code_review_request_status} == 'fail'"
    outputs: ["pm_code_review_decision"]
    config:
      step: "4.5-pm-code-review-prioritization"
      persona: "project-manager"
      intent: "prioritize_code_review_failures"
      payload:
        task: "${task}"
        milestone: "${milestone}"
        milestone_name: "${milestone_name}"
        milestone_description: "${milestone_description}"
        milestone_status: "${milestone_status}"
        code_review_result: "${code_review_request_result}"
        code_review_status: "${code_review_request_status}"
        milestone_completion_percentage: "${milestone_completion_percentage}"
        repo: "${repo_remote}"
        project_id: "${projectId}"
        context_for_pm: |
          You are evaluating code review failures for a task in the ${milestone_name} milestone.
          
          The code review results include severity-rated findings stored in .ma/reviews/task-{id}-code-review.log
          
          SEVERITY LEVELS EXPLAINED:
          - SEVERE: Blocking issues (compile errors, critical bugs, broken functionality) - MUST fix immediately
          - HIGH: Significant problems (major tech debt, performance issues, maintainability concerns) - Should fix before merge
          - MEDIUM: Code smells (minor violations, style issues, small refactors) - Can often defer to future tasks
          - LOW: Suggestions (refactoring opportunities, nice-to-haves) - Defer to backlog
          
          PROJECT STAGE CONTEXT:
          - Milestone: ${milestone_name}
          - Completion: ${milestone_completion_percentage}%
          - Status: ${milestone_status}
          
          DECISION FRAMEWORK:
          1. Review the code_review_result JSON (contains findings.severe, findings.high, findings.medium, findings.low arrays)
          2. ALWAYS require immediate fix if SEVERE or HIGH findings exist
          3. For MEDIUM findings:
             - Early stage (<50% milestone complete) OR MVP/POC: Can defer to backlog
             - Production/beta stage (>50% complete): Should fix before merge
          4. For LOW findings: Always defer to backlog as future improvements
          
          YOUR RESPONSE (JSON):
          {
            "decision": "defer" | "immediate_fix",
            "reasoning": "Explain why (include severity counts)",
            "immediate_issues": ["List of SEVERE and HIGH findings requiring immediate fix"],
            "deferred_issues": ["List of MEDIUM/LOW findings to add to backlog"],
            "follow_up_tasks": [{"title": "...", "description": "...", "priority": "low|medium|high"}]
          }
          
          If SEVERE or HIGH findings exist, decision MUST be "immediate_fix".
          If only MEDIUM/LOW findings exist, decision can be "defer" with backlog tasks created.

  # Create follow-up tasks from PM decision
  - name: create_code_review_followup_tasks
    type: ReviewFailureTasksStep
    description: "Create urgent follow-up tasks for code review failures"
    depends_on: ["pm_prioritize_code_review_failures"]
    outputs: ["code_review_tasks_created", "code_review_urgent_tasks_created"]
    config:
      pmDecisionVariable: "pm_code_review_decision"
      reviewType: "code_review"
      urgentPriorityScore: 1000
      deferredPriorityScore: 50
      createDeferredTasks: true
      backlogMilestoneSlug: "future-enhancements"

  # Mark task as blocked when code review fails - prevents loop
  - name: mark_task_needs_rework_after_code_review
    type: SimpleTaskStatusStep
    description: "Mark original task as blocked to prevent loop, urgent tasks created"
    depends_on: ["create_code_review_followup_tasks"]
    config:
      status: "blocked"
      comment: "Code review failed - urgent follow-up tasks created"

  # Security Review - evaluates security vulnerabilities and risks
  - name: security_request
    type: PersonaRequestStep
    description: "Request security review from security reviewer persona"
    depends_on: ["code_review_request"]
    condition: "${code_review_request_status} == 'pass'"
    outputs: ["security_request_result", "security_request_status"]
    config:
      step: "5-security"
      persona: "security-review"
      intent: "security_review"
      payload:
        task: "${task}"
        plan: "${planning_loop_plan_result}"
        implementation: "${implementation_request_result}"
        qa_result: "${qa_request_result}"
        code_review_result: "${code_review_request_result}"
        repo: "${repo_remote}"
        project_id: "${projectId}"

  # PM prioritizes security review failures - decides if issues need immediate fix or can be deferred
  - name: pm_prioritize_security_failures
    type: PersonaRequestStep
    description: "PM evaluates security review failures and prioritizes follow-up work"
    depends_on: ["security_request"]
    condition: "${security_request_status} == 'fail'"
    outputs: ["pm_security_decision"]
    config:
      step: "5.5-pm-security-prioritization"
      persona: "project-manager"
      intent: "prioritize_security_failures"
      payload:
        task: "${task}"
        milestone: "${milestone}"
        milestone_name: "${milestone_name}"
        milestone_description: "${milestone_description}"
        milestone_status: "${milestone_status}"
        security_result: "${security_request_result}"
        security_status: "${security_request_status}"
        code_review_result: "${code_review_request_result}"
        milestone_completion_percentage: "${milestone_completion_percentage}"
        repo: "${repo_remote}"
        project_id: "${projectId}"
        context_for_pm: |
          You are evaluating security review failures for a task in the ${milestone_name} milestone.
          
          The security review results include severity-rated findings stored in .ma/reviews/task-{id}-security-review.log
          
          SEVERITY LEVELS EXPLAINED:
          - SEVERE: Critical vulnerabilities (RCE, auth bypass, data exposure, SQL injection) - MUST fix immediately regardless of project stage
          - HIGH: Significant security risks (known CVEs, weak crypto, XSS, CSRF) - Should fix before merge
          - MEDIUM: Security concerns (missing security headers, outdated deps without known exploits) - Stage-dependent
          - LOW: Security improvements (hardening opportunities, defense-in-depth enhancements) - Defer to backlog
          
          PROJECT STAGE CONTEXT:
          - Milestone: ${milestone_name}
          - Completion: ${milestone_completion_percentage}%
          - Status: ${milestone_status}
          
          STAGE DETECTION GUIDANCE:
          Analyze milestone_name for stage indicators:
          - EARLY STAGE: Keywords like "MVP", "POC", "prototype", "initial", "foundation"
          - BETA STAGE: Keywords like "beta", "testing", "pre-release", "RC"
          - PRODUCTION STAGE: Keywords like "production", "release", "v1.0", "GA", "launch"
          
          DECISION FRAMEWORK:
          1. Review the security_result JSON (contains findings.severe, findings.high, findings.medium, findings.low arrays)
          2. ALWAYS require immediate fix if SEVERE findings exist (ANY stage)
          3. For HIGH findings:
             - Production/Beta: MUST fix immediately
             - Early stage: Should fix, but can defer if blocking development
          4. For MEDIUM findings:
             - Production: Should fix before merge
             - Beta: Can defer non-critical items
             - Early stage: Defer to backlog, focus on functionality first
          5. For LOW findings: Always defer to backlog as future improvements
          
          YOUR RESPONSE (JSON):
          {
            "decision": "defer" | "immediate_fix",
            "reasoning": "Explain why (include severity counts and detected stage)",
            "detected_stage": "early|beta|production",
            "immediate_issues": ["List of SEVERE/HIGH findings requiring immediate fix"],
            "deferred_issues": ["List of MEDIUM/LOW findings to add to backlog"],
            "follow_up_tasks": [{"title": "...", "description": "...", "priority": "low|medium|high|critical"}]
          }
          
          If SEVERE findings exist, decision MUST be "immediate_fix" (regardless of stage).
          If HIGH findings exist in production/beta, decision MUST be "immediate_fix".
          If only MEDIUM/LOW findings exist, decision can be "defer" with backlog tasks created.

  # Create follow-up tasks from security PM decision
  - name: create_security_review_followup_tasks
    type: ReviewFailureTasksStep
    description: "Create urgent follow-up tasks for security review failures"
    depends_on: ["pm_prioritize_security_failures"]
    outputs: ["security_review_tasks_created", "security_review_urgent_tasks_created"]
    config:
      pmDecisionVariable: "pm_security_decision"
      reviewType: "security_review"
      urgentPriorityScore: 1500
      deferredPriorityScore: 50
      createDeferredTasks: true
      backlogMilestoneSlug: "future-enhancements"

  # Mark task as blocked when security review fails - prevents loop
  - name: mark_task_security_blocked
    type: SimpleTaskStatusStep
    description: "Mark original task as blocked due to security issues"
    depends_on: ["create_security_review_followup_tasks"]
    config:
      status: "blocked"
      comment: "Security review failed - urgent follow-up tasks created"

  # DevOps Review - evaluates deployment and operational concerns
  - name: devops_request
    type: PersonaRequestStep
    description: "Request DevOps review from DevOps persona"
    depends_on: ["security_request"]
    condition: "${security_request_status} == 'pass'"
    outputs: ["devops_request_result", "devops_request_status"]
    config:
      step: "6-devops"
      persona: "devops"
      intent: "devops_review"
      payload:
        task: "${task}"
        plan: "${planning_loop_plan_result}"
        implementation: "${implementation_request_result}"
        qa_result: "${qa_request_result}"
        code_review_result: "${code_review_request_result}"
        security_result: "${security_request_result}"
        repo: "${repo_remote}"
        project_id: "${projectId}"

  # Mark task as done only when security review passes
  - name: mark_task_done
    type: SimpleTaskStatusStep
    description: "Mark task as completed on dashboard when all reviews pass"
    depends_on: ["devops_request"]
    condition: "${security_request_status} == 'pass'"
    config:
      task_id: "${taskId}"
      project_id: "${projectId}"
      status: "done"

  # Check milestone completion status
  - name: check_milestone_completion
    type: MilestoneStatusCheckStep
    description: "Check if milestone has remaining incomplete tasks"
    depends_on: ["mark_task_done"]
    config:
      check_type: "incomplete_tasks"
      include_cancelled: false

  # Send suggested tasks to PM for urgency evaluation if milestone incomplete
  - name: pm_evaluate_suggestions
    type: PersonaRequestStep
    description: "Send suggested tasks to PM for urgency evaluation"
    depends_on: ["check_milestone_completion"]
    condition: "${milestone_has_remaining_tasks} == true"
    config:
      step: "6-pm-evaluate-suggestions"
      persona: "project-manager"
      intent: "evaluate_task_urgency"
      payload:
        milestone: "${milestone}"
        completed_task: "${task}"
        remaining_tasks: "${check_milestone_completion_remaining_tasks}"
        suggested_tasks: "${qa_iteration_loop_suggested_tasks}"
        milestone_completion_percentage: "${milestone_completion_percentage}"
        repo: "${repo_remote}"
        project_id: "${projectId}"

# Failure handling - mark task as blocked when workflow fails
failure_handling:
  on_workflow_failure:
    - name: mark_task_blocked
      type: SimpleTaskStatusStep
      description: "Mark task as blocked when workflow fails"
      config:
        status: "blocked"

# Workflow timeouts
timeouts:
  context_request_timeout: 600000  # 10 minutes for context gathering
  default_step: 300000  # 5 minutes default